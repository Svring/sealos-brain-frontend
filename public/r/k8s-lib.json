{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "k8s-lib",
  "type": "registry:lib",
  "title": "Kubernetes Library",
  "description": "Complete Kubernetes library with API clients, query functions, mutation operations, and utility functions for server-side and client-side operations.",
  "dependencies": [
    "@kubernetes/client-node",
    "fast-json-patch",
    "js-yaml",
    "lodash"
  ],
  "registryDependencies": [
    "k8s-models",
    "k8s-constants"
  ],
  "files": [
    {
      "path": "src/registry/new-york/lib/k8s/k8s-client.utils.ts",
      "content": "/**\n * Client-side Kubernetes utilities\n *\n * This file contains utility functions that can be used on the client side\n * for Kubernetes-related operations that don't require server-side execution.\n */\n\n/**\n * Helper to add missing apiVersion and kind to builtin resource lists.\n * This ensures all resources have the proper apiVersion and kind fields.\n */\nexport async function addMissingFields<T extends Record<string, unknown>>(\n\titems: T[],\n\tapiVersion: string,\n\tkind: string,\n): Promise<{\n\tapiVersion: string;\n\tkind: string;\n\titems: T[];\n}> {\n\tawait new Promise((resolve) => setTimeout(resolve, 0));\n\treturn {\n\t\tapiVersion: `${apiVersion}List`,\n\t\tkind: `${kind}List`,\n\t\titems: items.map((item) => ({\n\t\t\tapiVersion,\n\t\t\tkind,\n\t\t\t...item,\n\t\t})),\n\t};\n}\n\n/**\n * Helper function to escape slashes in keys for JSON Patch paths\n */\nexport function escapeSlash(key: string): string {\n\treturn key.replace(/\\//g, \"~1\");\n}\n\n/**\n * Convert Kubernetes resource quantity string to universal units\n * @param quantity - Kubernetes resource quantity string (e.g., \"64\", \"20200m\", \"96Gi\", \"25828Mi\")\n * @param resourceType - Type of resource (\"cpu\", \"memory\", \"storage\", or \"other\")\n * @returns Converted numeric value in universal units (cores for CPU, GB for memory/storage, raw number for others)\n */\nexport function standardizeUnit(\n\tquantity: string,\n\tresourceType: \"cpu\" | \"memory\" | \"storage\" | \"other\" = \"other\",\n): number {\n\tif (!quantity || typeof quantity !== \"string\") {\n\t\treturn 0;\n\t}\n\n\t// Handle CPU resources\n\tif (resourceType === \"cpu\") {\n\t\tif (quantity.endsWith(\"m\")) {\n\t\t\t// Convert millicores to cores (e.g., \"20200m\" -> 20.2)\n\t\t\treturn parseFloat(quantity.slice(0, -1)) / 1000;\n\t\t} else {\n\t\t\t// Direct cores (e.g., \"64\" -> 64)\n\t\t\treturn parseFloat(quantity);\n\t\t}\n\t}\n\n\t// Handle memory and storage resources\n\tif (resourceType === \"memory\" || resourceType === \"storage\") {\n\t\tif (quantity.endsWith(\"Gi\")) {\n\t\t\t// Convert GiB to GB (e.g., \"96Gi\" -> 96)\n\t\t\treturn parseFloat(quantity.slice(0, -2));\n\t\t} else if (quantity.endsWith(\"Mi\")) {\n\t\t\t// Convert MiB to GB (e.g., \"25828Mi\" -> 25.828)\n\t\t\treturn parseFloat(quantity.slice(0, -2)) / 1024;\n\t\t} else if (quantity.endsWith(\"Ki\")) {\n\t\t\t// Convert KiB to GB (e.g., \"1048576Ki\" -> 1)\n\t\t\treturn parseFloat(quantity.slice(0, -2)) / (1024 * 1024);\n\t\t} else if (quantity.endsWith(\"G\")) {\n\t\t\t// Direct GB (e.g., \"100G\" -> 100)\n\t\t\treturn parseFloat(quantity.slice(0, -1));\n\t\t} else if (quantity.endsWith(\"M\")) {\n\t\t\t// Convert MB to GB (e.g., \"1000M\" -> 1)\n\t\t\treturn parseFloat(quantity.slice(0, -1)) / 1000;\n\t\t} else if (quantity.endsWith(\"K\")) {\n\t\t\t// Convert KB to GB (e.g., \"1000000K\" -> 0.001)\n\t\t\treturn parseFloat(quantity.slice(0, -1)) / (1000 * 1000);\n\t\t} else {\n\t\t\t// Assume bytes and convert to GB\n\t\t\treturn parseFloat(quantity) / (1024 * 1024 * 1024);\n\t\t}\n\t}\n\n\t// Handle other resources (counts, custom resources, etc.)\n\treturn parseFloat(quantity) || 0;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/new-york/lib/k8s/k8s-mutation.api.ts",
      "content": "\"use server\";\n\nimport type { Operation } from \"fast-json-patch\";\nimport { load } from \"js-yaml\";\nimport _ from \"lodash\";\nimport { CUSTOM_RESOURCES } from \"@/registry/dark/constants/k8s/k8s-custom.constant\";\nimport { escapeSlash } from \"@/registry/dark/lib/k8s/k8s-client.utils\";\nimport {\n\tgetApiClients,\n\tgetBuiltinApiClient,\n\tgetCurrentNamespace,\n\tinvokeApiMethod,\n} from \"@/registry/dark/lib/k8s/k8s-server.utils\";\nimport type {\n\tBuiltinResourceTarget,\n\tCustomResourceTarget,\n\tResourceTarget,\n} from \"@/registry/dark/models/k8s/k8s.model\";\nimport type { K8sContext } from \"@/registry/dark/models/k8s/k8s-context.model\";\n\n/**\n * Delete a custom resource by name in Kubernetes.\n */\nexport const deleteCustomResource = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTarget,\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for deletion\");\n\t}\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclients.customApi,\n\t\t\"deleteNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t},\n\t);\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Upsert (create or update) a custom resource in Kubernetes.\n * This is the primary method for managing custom resources - it will create if the resource doesn't exist, or update if it does.\n */\nexport const upsertCustomResource = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTarget,\n\tresourceBody: Record<string, unknown>,\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tconst resourceName = (resourceBody.metadata as any)?.name || target.name;\n\tif (_.isNil(resourceName)) {\n\t\tthrow new Error(\"Resource name is required in metadata or target\");\n\t}\n\n\ttry {\n\t\t// Try to get the existing resource\n\t\tawait invokeApiMethod<any>(clients.customApi, \"getNamespacedCustomObject\", {\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: resourceName,\n\t\t});\n\n\t\t// If found, update it\n\t\tconst result = await invokeApiMethod<any>(\n\t\t\tclients.customApi,\n\t\t\t\"replaceNamespacedCustomObject\",\n\t\t\t{\n\t\t\t\tgroup: customResourceConfig.group,\n\t\t\t\tversion: customResourceConfig.version,\n\t\t\t\tnamespace: namespace || \"default\",\n\t\t\t\tplural: customResourceConfig.plural,\n\t\t\t\tname: resourceName,\n\t\t\t\tbody: resourceBody,\n\t\t\t},\n\t\t);\n\n\t\treturn JSON.parse(JSON.stringify(result));\n\t} catch (error: unknown) {\n\t\t// Assume resource doesn't exist, create it\n\t\tconst result = await invokeApiMethod<any>(\n\t\t\tclients.customApi,\n\t\t\t\"createNamespacedCustomObject\",\n\t\t\t{\n\t\t\t\tgroup: customResourceConfig.group,\n\t\t\t\tversion: customResourceConfig.version,\n\t\t\t\tnamespace: namespace || \"default\",\n\t\t\t\tplural: customResourceConfig.plural,\n\t\t\t\tbody: resourceBody,\n\t\t\t},\n\t\t);\n\n\t\treturn JSON.parse(JSON.stringify(result));\n\t}\n};\n\n/**\n * Upsert (create or update) a builtin resource in Kubernetes.\n * This is the primary method for managing builtin resources - it will create if the resource doesn't exist, or update if it does.\n */\nexport const upsertBuiltinResource = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTarget,\n\tresourceBody: Record<string, unknown>,\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tconst resourceName = (resourceBody.metadata as any)?.name || target.name;\n\tif (_.isNil(resourceName)) {\n\t\tthrow new Error(\"Resource name is required in metadata or target\");\n\t}\n\n\ttry {\n\t\t// Try to get the existing resource\n\t\tawait invokeApiMethod<any>(client, resourceConfig.getMethod, {\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: resourceName,\n\t\t});\n\n\t\t// If found, update it\n\t\tconst result = await invokeApiMethod<any>(\n\t\t\tclient,\n\t\t\tresourceConfig.replaceMethod,\n\t\t\t{\n\t\t\t\tnamespace: namespace || \"default\",\n\t\t\t\tname: resourceName,\n\t\t\t\tbody: resourceBody,\n\t\t\t},\n\t\t);\n\n\t\treturn JSON.parse(JSON.stringify(result));\n\t} catch (error: unknown) {\n\t\t// Assume resource doesn't exist, create it\n\t\tconst result = await invokeApiMethod<any>(\n\t\t\tclient,\n\t\t\tresourceConfig.createMethod,\n\t\t\t{\n\t\t\t\tnamespace: namespace || \"default\",\n\t\t\t\tbody: resourceBody,\n\t\t\t},\n\t\t);\n\n\t\treturn JSON.parse(JSON.stringify(result));\n\t}\n};\n\n/**\n * Upsert resource content for any resource type (generic version).\n * This function parses JSON or YAML content and creates or updates the resource.\n *\n * @example\n * ```typescript\n * const result = await applyResource(context,\n *   { type: \"custom\", resourceType: \"instance\", name: \"my-instance\" },\n *   yamlContent\n * );\n * ```\n */\nexport const applyResource = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n\tresourceContent: string | Record<string, unknown>,\n) => {\n\t// Parse resource content\n\tconst resource =\n\t\ttypeof resourceContent === \"string\"\n\t\t\t? _.attempt(JSON.parse, resourceContent) instanceof Error\n\t\t\t\t? (load(resourceContent) as Record<string, unknown>)\n\t\t\t\t: JSON.parse(resourceContent)\n\t\t\t: resourceContent;\n\n\tconst { name } = resource.metadata as { name: string };\n\tif (_.isNil(name))\n\t\tthrow new Error(\"Resource name is required in YAML metadata\");\n\n\t// Use provided target\n\treturn target.type === \"custom\"\n\t\t? await upsertCustomResource(context, target, resource)\n\t\t: await upsertBuiltinResource(context, target, resource);\n};\n\n/**\n * Delete a builtin resource by name in Kubernetes.\n */\nexport const deleteBuiltinResource = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTarget,\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for deletion\");\n\t}\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclient,\n\t\tresourceConfig.deleteMethod,\n\t\t{\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: target.name,\n\t\t\tpropagationPolicy: \"Foreground\",\n\t\t},\n\t);\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Patch custom resource metadata (annotations or labels).\n */\nexport const patchCustomResourceMetadata = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTarget,\n\tmetadataType: \"annotations\" | \"labels\",\n\tkey: string,\n\tvalue: string,\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for metadata patching\");\n\t}\n\n\t// Get current resource to check if metadata field exists\n\tconst currentResource = await invokeApiMethod<any>(\n\t\tclients.customApi,\n\t\t\"getNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t},\n\t);\n\n\tconst patchBody = currentResource.metadata?.[metadataType]\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: `/metadata/${metadataType}/${await escapeSlash(key)}`,\n\t\t\t\t\tvalue,\n\t\t\t\t},\n\t\t\t]\n\t\t: [\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: `/metadata/${metadataType}`,\n\t\t\t\t\tvalue: { [key]: value },\n\t\t\t\t},\n\t\t\t];\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclients.customApi,\n\t\t\"patchNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Remove custom resource metadata (annotations or labels).\n */\nexport const removeCustomResourceMetadata = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTarget,\n\tmetadataType: \"annotations\" | \"labels\",\n\tkey: string,\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for metadata removal\");\n\t}\n\n\t// Get current resource to check if the annotation/label exists\n\tconst currentResource = await invokeApiMethod<any>(\n\t\tclients.customApi,\n\t\t\"getNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t},\n\t);\n\n\t// Check if the metadata field and specific key exist\n\tconst metadata = currentResource.metadata?.[metadataType];\n\tif (!metadata || !_.has(metadata, key)) {\n\t\t// If the annotation/label doesn't exist, return the current resource as-is\n\t\t// This prevents 422 errors when trying to remove non-existent paths\n\t\treturn JSON.parse(JSON.stringify(currentResource));\n\t}\n\n\tconst patchBody = [\n\t\t{\n\t\t\top: \"remove\",\n\t\t\tpath: `/metadata/${metadataType}/${await escapeSlash(key)}`,\n\t\t},\n\t];\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclients.customApi,\n\t\t\"patchNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Patch builtin resource metadata (annotations or labels).\n */\nexport const patchBuiltinResourceMetadata = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTarget,\n\tmetadataType: \"annotations\" | \"labels\",\n\tkey: string,\n\tvalue: string,\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for metadata patching\");\n\t}\n\n\t// Get current resource to check if metadata field exists\n\tconst currentResource = await invokeApiMethod<any>(\n\t\tclient,\n\t\tresourceConfig.getMethod,\n\t\t{\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: target.name,\n\t\t},\n\t);\n\n\tconst patchBody = currentResource.metadata?.[metadataType]\n\t\t? [\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: `/metadata/${metadataType}/${await escapeSlash(key)}`,\n\t\t\t\t\tvalue,\n\t\t\t\t},\n\t\t\t]\n\t\t: [\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: `/metadata/${metadataType}`,\n\t\t\t\t\tvalue: { [key]: value },\n\t\t\t\t},\n\t\t\t];\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclient,\n\t\tresourceConfig.patchMethod,\n\t\t{\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Remove builtin resource metadata (annotations or labels).\n */\nexport const removeBuiltinResourceMetadata = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTarget,\n\tmetadataType: \"annotations\" | \"labels\",\n\tkey: string,\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for metadata removal\");\n\t}\n\n\t// Get current resource to check if the annotation/label exists\n\tconst currentResource = await invokeApiMethod<any>(\n\t\tclient,\n\t\tresourceConfig.getMethod,\n\t\t{\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: target.name,\n\t\t},\n\t);\n\n\t// Check if the metadata field and specific key exist\n\tconst metadata = currentResource.metadata?.[metadataType];\n\tif (!metadata || !_.has(metadata, key)) {\n\t\t// If the annotation/label doesn't exist, return the current resource as-is\n\t\t// This prevents 422 errors when trying to remove non-existent paths\n\t\treturn JSON.parse(JSON.stringify(currentResource));\n\t}\n\n\tconst patchBody = [\n\t\t{\n\t\t\top: \"remove\",\n\t\t\tpath: `/metadata/${metadataType}/${await escapeSlash(key)}`,\n\t\t},\n\t];\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclient,\n\t\tresourceConfig.patchMethod,\n\t\t{\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Patch a custom resource with arbitrary patch operations.\n */\nexport const patchCustomResource = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTarget,\n\tpatchBody: Operation[],\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for patching\");\n\t}\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclients.customApi,\n\t\t\"patchNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Patch a builtin resource with arbitrary patch operations.\n */\nexport const patchBuiltinResource = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTarget,\n\tpatchBody: Operation[],\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for patching\");\n\t}\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclient,\n\t\tresourceConfig.patchMethod,\n\t\t{\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Strategic merge patch for custom resources.\n * This allows partial updates without needing to get the full resource first.\n */\nexport const strategicMergePatchCustomResource = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTarget,\n\tpatchBody: Record<string, unknown>,\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for patching\");\n\t}\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclients.customApi,\n\t\t\"patchNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t\toptions: {\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/strategic-merge-patch+json\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n\n/**\n * Strategic merge patch for builtin resources.\n * This allows partial updates without needing to get the full resource first.\n */\nexport const strategicMergePatchBuiltinResource = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTarget,\n\tpatchBody: Record<string, unknown>,\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (_.isNil(target.name)) {\n\t\tthrow new Error(\"Resource name is required for patching\");\n\t}\n\n\tconst result = await invokeApiMethod<any>(\n\t\tclient,\n\t\tresourceConfig.patchMethod,\n\t\t{\n\t\t\tnamespace: namespace || \"default\",\n\t\t\tname: target.name,\n\t\t\tbody: patchBody,\n\t\t\toptions: {\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/strategic-merge-patch+json\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(result));\n};\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/new-york/lib/k8s/k8s-query.api.ts",
      "content": "\"use server\";\n\nimport { CUSTOM_RESOURCES } from \"@/registry/dark/constants/k8s/k8s-custom.constant\";\nimport { addMissingFields } from \"@/registry/dark/lib/k8s/k8s-client.utils\";\nimport {\n\tgetApiClients,\n\tgetBuiltinApiClient,\n\tgetCurrentNamespace,\n\tinvokeApiMethod,\n} from \"@/registry/dark/lib/k8s/k8s-server.utils\";\nimport type {\n\tBuiltinResourceTarget,\n\tBuiltinResourceTypeTarget,\n\tCustomResourceTarget,\n\tCustomResourceTypeTarget,\n} from \"@/registry/dark/models/k8s/k8s.model\";\nimport type { K8sContext } from \"@/registry/dark/models/k8s/k8s-context.model\";\n\n// ============================================================================\n// Kubernetes API Query Functions\n// ============================================================================\n\nexport const listCustomResources = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTypeTarget,\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tif (!namespace) {\n\t\tthrow new Error(\"Namespace is required but not found in kubeconfig\");\n\t}\n\n\tconst customResourceListResponse = await invokeApiMethod(\n\t\tclients.customApi,\n\t\t\"listNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace,\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tlabelSelector:\n\t\t\t\ttarget.label && target.name\n\t\t\t\t\t? `${target.label}=${target.name}`\n\t\t\t\t\t: undefined,\n\t\t},\n\t);\n\treturn JSON.parse(JSON.stringify(customResourceListResponse));\n};\n\nexport const getCustomResource = async (\n\tcontext: K8sContext,\n\ttarget: CustomResourceTarget,\n) => {\n\tconst { clients } = await getApiClients(context.kubeconfig);\n\tconst customResourceConfig = CUSTOM_RESOURCES[target.resourceType];\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!customResourceConfig) {\n\t\tthrow new Error(`Unknown custom resource type: ${target.resourceType}`);\n\t}\n\n\tif (!namespace) {\n\t\tthrow new Error(\"Namespace is required but not found in kubeconfig\");\n\t}\n\n\tconst customResourceGetResponse = await invokeApiMethod(\n\t\tclients.customApi,\n\t\t\"getNamespacedCustomObject\",\n\t\t{\n\t\t\tgroup: customResourceConfig.group,\n\t\t\tversion: customResourceConfig.version,\n\t\t\tnamespace,\n\t\t\tplural: customResourceConfig.plural,\n\t\t\tname: target.name,\n\t\t},\n\t);\n\treturn JSON.parse(JSON.stringify(customResourceGetResponse));\n};\n\nexport const listBuiltinResources = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTypeTarget,\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!namespace) {\n\t\tthrow new Error(\"Namespace is required but not found in kubeconfig\");\n\t}\n\n\tconst builtinResourceListResponse = await invokeApiMethod<{\n\t\titems: any[];\n\t}>(client, resourceConfig.listMethod, {\n\t\tnamespace,\n\t\tlabelSelector:\n\t\t\ttarget.label && target.name\n\t\t\t\t? `${target.label}=${target.name}`\n\t\t\t\t: undefined,\n\t});\n\n\treturn JSON.parse(\n\t\tJSON.stringify(\n\t\t\tawait addMissingFields(\n\t\t\t\tbuiltinResourceListResponse.items,\n\t\t\t\tresourceConfig.apiVersion,\n\t\t\t\tresourceConfig.kind,\n\t\t\t),\n\t\t),\n\t);\n};\n\nexport const getBuiltinResource = async (\n\tcontext: K8sContext,\n\ttarget: BuiltinResourceTarget,\n) => {\n\tconst { client, resourceConfig } = await getBuiltinApiClient(\n\t\tcontext.kubeconfig,\n\t\ttarget.resourceType,\n\t);\n\tconst namespace = await getCurrentNamespace(context.kubeconfig);\n\n\tif (!namespace) {\n\t\tthrow new Error(\"Namespace is required but not found in kubeconfig\");\n\t}\n\n\tconst builtinResourceGetResponse = await invokeApiMethod(\n\t\tclient,\n\t\tresourceConfig.getMethod,\n\t\t{\n\t\t\tnamespace,\n\t\t\tname: target.name,\n\t\t},\n\t);\n\n\treturn JSON.parse(JSON.stringify(builtinResourceGetResponse));\n};\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/new-york/lib/k8s/k8s-server.utils.ts",
      "content": "\"use server\";\n\nimport {\n\tAppsV1Api,\n\tAutoscalingV2Api,\n\tBatchV1Api,\n\tCoreV1Api,\n\tCustomObjectsApi,\n\tKubeConfig,\n\tNetworkingV1Api,\n\tRbacAuthorizationV1Api,\n} from \"@kubernetes/client-node\";\nimport _ from \"lodash\";\nimport { BUILTIN_RESOURCES } from \"@/registry/dark/constants/k8s/k8s-builtin.constant\";\nimport type { BuiltinResourceConfig } from \"@/registry/dark/models/k8s/k8s-builtin.model\";\nimport type { K8sApiClients } from \"@/registry/dark/models/k8s/k8s-clients.model\";\n\n/**\n * Get the current namespace from a kubeconfig string.\n * @param kubeconfig - The kubeconfig string.\n * @returns The current namespace, or 'default' if not set.\n */\nexport async function getCurrentNamespace(\n\tkubeconfig: string,\n): Promise<string | undefined> {\n\tconst kc = new KubeConfig();\n\tkc.loadFromString(kubeconfig);\n\tconst currentContext = kc.getCurrentContext();\n\tconst contextObj = kc.getContextObject(currentContext);\n\treturn contextObj?.namespace;\n}\n\n/**\n * Extract the region URL from a kubeconfig string.\n * @param kubeconfig - The kubeconfig string.\n * @returns The region URL (hostname without port), or undefined if not found.\n * @example\n * // For server: \"https://bja.sealos.run:6443\"\n * // Returns: \"bja.sealos.run\"\n */\nexport async function getRegionUrlFromKubeconfig(\n\tkubeconfig: string,\n): Promise<string | undefined> {\n\ttry {\n\t\tconst kc = new KubeConfig();\n\t\tkc.loadFromString(kubeconfig);\n\n\t\tconst currentContext = kc.getCurrentContext();\n\t\tconst contextObj = kc.getContextObject(currentContext);\n\n\t\tif (!contextObj?.cluster) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst clusterObj = kc.getCluster(contextObj.cluster);\n\t\tif (!clusterObj?.server) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Parse the server URL to extract hostname\n\t\tconst url = new URL(clusterObj.server);\n\t\treturn url.hostname;\n\t} catch (error) {\n\t\tconsole.error(\"Failed to extract region URL from kubeconfig:\", error);\n\t\treturn undefined;\n\t}\n}\n\n/**\n * Helper to add missing apiVersion and kind to builtin resource lists.\n */\nexport async function addMissingFields<T extends Record<string, unknown>>(\n\titems: T[],\n\tapiVersion: string,\n\tkind: string,\n): Promise<{\n\tapiVersion: string;\n\tkind: string;\n\titems: T[];\n}> {\n\tawait new Promise((resolve) => setTimeout(resolve, 0));\n\treturn {\n\t\tapiVersion: `${apiVersion}List`,\n\t\tkind: `${kind}List`,\n\t\titems: items.map((item) => ({\n\t\t\tapiVersion,\n\t\t\tkind,\n\t\t\t...item,\n\t\t})),\n\t};\n}\n\nconst clientCache: Record<string, { kc: KubeConfig; clients: K8sApiClients }> =\n\t{};\n\nexport async function getApiClients(\n\tkubeconfig: string,\n): Promise<{ kc: KubeConfig; clients: K8sApiClients }> {\n\tif (_.has(clientCache, kubeconfig)) {\n\t\treturn _.get(clientCache, kubeconfig);\n\t}\n\tconst kc = new KubeConfig();\n\tkc.loadFromString(kubeconfig);\n\tconst clients: K8sApiClients = {\n\t\tcustomApi: kc.makeApiClient(CustomObjectsApi),\n\t\tappsApi: kc.makeApiClient(AppsV1Api),\n\t\tautoscalingApi: kc.makeApiClient(AutoscalingV2Api),\n\t\tbatchApi: kc.makeApiClient(BatchV1Api),\n\t\tcoreApi: kc.makeApiClient(CoreV1Api),\n\t\tnetworkingApi: kc.makeApiClient(NetworkingV1Api),\n\t\trbacApi: kc.makeApiClient(RbacAuthorizationV1Api),\n\t};\n\t_.set(clientCache, kubeconfig, { kc, clients });\n\treturn { kc, clients };\n}\n\n/**\n * Type-safe method invoker for API clients\n */\nexport async function invokeApiMethod<T>(\n\tclient: K8sApiClients[keyof K8sApiClients],\n\tmethodName: string,\n\tparams: Record<string, unknown> | unknown[] = {},\n): Promise<T> {\n\tif (!_.isObject(client)) {\n\t\tthrow new Error(\"Client must be a valid API client object\");\n\t}\n\tif (!_.isString(methodName) || _.isEmpty(methodName)) {\n\t\tthrow new Error(\"Method name must be a non-empty string\");\n\t}\n\tif (!_.isObject(params) && !_.isArray(params)) {\n\t\tthrow new Error(\"Params must be an object or array\");\n\t}\n\n\tconst method = _.get(client, methodName);\n\tif (!_.isFunction(method)) {\n\t\tthrow new Error(\n\t\t\t`Method ${methodName} not found or not a function on client: ${JSON.stringify(\n\t\t\t\tclient,\n\t\t\t)}`,\n\t\t);\n\t}\n\n\tconst args = _.isArray(params) ? params : [params];\n\n\tconst result = await _.attempt(async () => method.call(client, ...args));\n\tif (_.isError(result)) {\n\t\t// Handle 404 errors for delete operations - treat as successful since the resource is already gone\n\t\tif (\n\t\t\tmethodName.toLowerCase().includes(\"delete\") &&\n\t\t\t(result.message.includes(\"404\") ||\n\t\t\t\tresult.message.includes(\"HTTP-Code: 404\") ||\n\t\t\t\tresult.message.includes(\"not found\"))\n\t\t) {\n\t\t\treturn {} as T;\n\t\t}\n\t\tthrow new Error(`Failed to invoke ${methodName}: ${result.message}`);\n\t}\n\n\treturn result as T;\n}\n\n/**\n * Get the correct API client for a builtin resource type, given kubeconfig and resourceType.\n */\nexport async function getBuiltinApiClient(\n\tkubeconfig: string,\n\tresourceType: string,\n): Promise<{\n\tclient: K8sApiClients[keyof K8sApiClients];\n\tresourceConfig: BuiltinResourceConfig;\n}> {\n\tconst { clients } = await getApiClients(kubeconfig);\n\tconst resourceConfig = BUILTIN_RESOURCES[\n\t\tresourceType\n\t] as BuiltinResourceConfig;\n\tif (_.isNil(resourceConfig)) {\n\t\tthrow new Error(`Unknown builtin resource type: ${resourceType}`);\n\t}\n\treturn {\n\t\tclient: clients[resourceConfig.apiClient as keyof K8sApiClients],\n\t\tresourceConfig,\n\t};\n}\n\n\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/new-york/lib/k8s/k8s-service.api.ts",
      "content": "\"use server\";\n\nimport type { Operation } from \"fast-json-patch\";\nimport _ from \"lodash\";\nimport {\n\tapplyResource as applyResourceMutation,\n\tdeleteBuiltinResource,\n\tdeleteCustomResource,\n\tpatchBuiltinResource,\n\tpatchBuiltinResourceMetadata,\n\tpatchCustomResource,\n\tpatchCustomResourceMetadata,\n\tremoveBuiltinResourceMetadata,\n\tremoveCustomResourceMetadata,\n\tstrategicMergePatchBuiltinResource,\n\tstrategicMergePatchCustomResource,\n\tupsertBuiltinResource,\n\tupsertCustomResource,\n} from \"@/registry/dark/lib/k8s/k8s-mutation.api\";\nimport {\n\tgetBuiltinResource,\n\tgetCustomResource,\n\tlistBuiltinResources,\n\tlistCustomResources,\n} from \"@/registry/dark/lib/k8s/k8s-query.api\";\nimport type {\n\tBuiltinResourceTarget,\n\tBuiltinResourceTypeTarget,\n\tCustomResourceTarget,\n\tCustomResourceTypeTarget,\n\tResourceTarget,\n\tResourceTypeTarget,\n} from \"@/registry/dark/models/k8s/k8s.model\";\nimport type { K8sContext } from \"@/registry/dark/models/k8s/k8s-context.model\";\nimport type { K8sResource } from \"@/registry/dark/models/k8s/k8s-resource.model\";\nimport { K8sResourceListSchema } from \"@/registry/dark/models/k8s/k8s-resource.model\";\n\n// ============================================================================\n// Resource Selection Functions\n// ============================================================================\n\n/**\n * Select specific resources based on provided resource type targets.\n * This function allows selecting only the resources specified in the targets array.\n * Returns a flattened array of all K8sResource objects from all targets.\n *\n * @example\n * ```typescript\n * // Select specific builtin and custom resources\n * const selectedResources = await selectResources(context, [\n *   { type: \"builtin\", resourceType: \"pod\", label: \"app\", name: \"my-app\" },\n *   { type: \"builtin\", resourceType: \"service\", label: \"app\", name: \"my-app\" },\n *   { type: \"custom\", resourceType: \"devbox\", label: \"app\", name: \"my-app\" },\n *   { type: \"custom\", resourceType: \"instance\", label: \"app\", name: \"my-app\" }\n * ]);\n * ```\n */\nexport const selectResources = async (\n\tcontext: K8sContext,\n\ttargets: ResourceTypeTarget[],\n): Promise<K8sResource[]> => {\n\t// Execute all resource queries in parallel\n\tconst resourcePromises = targets.map((target) =>\n\t\tlistResources(context, target),\n\t);\n\n\t// Wait for all promises to complete\n\tconst results = await Promise.all(resourcePromises);\n\n\t// Flatten all resources into a single array\n\tconst allResources = _.flatMap(results, (result) => {\n\t\tif (result?.items) {\n\t\t\treturn K8sResourceListSchema.parse(result).items;\n\t\t}\n\t\treturn [];\n\t});\n\n\treturn allResources;\n};\n\n// ============================================================================\n// Unified Kubernetes Service API Functions\n// ============================================================================\n\n/**\n * List resources automatically determining if they are builtin or custom.\n *\n * @example\n * ```typescript\n * // List custom resources\n * const instances = await listResources(context, {\n *   type: \"custom\",\n *   resourceType: \"instance\",\n *   label: \"app\",\n *   name: \"my-app\"\n * });\n *\n * // List builtin resources\n * const pods = await listResources(context, {\n *   type: \"builtin\",\n *   resourceType: \"pod\",\n *   label: \"app\",\n *   name: \"my-app\"\n * });\n * ```\n */\nexport const listResources = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTypeTarget,\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await listCustomResources(\n\t\t\tcontext,\n\t\t\ttarget as CustomResourceTypeTarget,\n\t\t);\n\t} else {\n\t\treturn await listBuiltinResources(\n\t\t\tcontext,\n\t\t\ttarget as BuiltinResourceTypeTarget,\n\t\t);\n\t}\n};\n\n/**\n * Get a specific resource automatically determining if it's builtin or custom.\n *\n * @example\n * ```typescript\n * // Get custom resource\n * const instance = await getResource(context, {\n *   type: \"custom\",\n *   resourceType: \"instance\",\n *   name: \"my-instance\"\n * });\n *\n * // Get builtin resource\n * const pod = await getResource(context, {\n *   type: \"builtin\",\n *   resourceType: \"pod\",\n *   name: \"my-pod\"\n * });\n * ```\n */\nexport const getResource = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await getCustomResource(context, target as CustomResourceTarget);\n\t} else {\n\t\treturn await getBuiltinResource(context, target as BuiltinResourceTarget);\n\t}\n};\n\n/**\n * Delete a resource automatically determining if it's builtin or custom.\n *\n * @example\n * ```typescript\n * // Delete custom resource\n * await deleteResource(context, {\n *   type: \"custom\",\n *   resourceType: \"instance\",\n *   name: \"my-instance\"\n * });\n *\n * // Delete builtin resource\n * await deleteResource(context, {\n *   type: \"builtin\",\n *   resourceType: \"pod\",\n *   name: \"my-pod\"\n * });\n * ```\n */\nexport const deleteResource = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await deleteCustomResource(context, target as CustomResourceTarget);\n\t} else {\n\t\treturn await deleteBuiltinResource(\n\t\t\tcontext,\n\t\t\ttarget as BuiltinResourceTarget,\n\t\t);\n\t}\n};\n\n/**\n * Upsert (create or update) a resource automatically determining if it's builtin or custom.\n *\n * @example\n * ```typescript\n * // Upsert custom resource\n * const instance = await upsertResource(context,\n *   { type: \"custom\", resourceType: \"instance\", name: \"my-instance\" },\n *   { metadata: { name: \"my-instance\" }, spec: { ... } }\n * );\n *\n * // Upsert builtin resource\n * const pod = await upsertResource(context,\n *   { type: \"builtin\", resourceType: \"pod\", name: \"my-pod\" },\n *   { metadata: { name: \"my-pod\" }, spec: { ... } }\n * );\n * ```\n */\nexport const upsertResource = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n\tresourceBody: Record<string, unknown>,\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await upsertCustomResource(\n\t\t\tcontext,\n\t\t\ttarget as CustomResourceTarget,\n\t\t\tresourceBody,\n\t\t);\n\t} else {\n\t\treturn await upsertBuiltinResource(\n\t\t\tcontext,\n\t\t\ttarget as BuiltinResourceTarget,\n\t\t\tresourceBody,\n\t\t);\n\t}\n};\n\n/**\n * Patch resource metadata (annotations or labels) automatically determining if it's builtin or custom.\n *\n * @example\n * ```typescript\n * // Patch custom resource metadata\n * await patchResourceMetadata(context,\n *   { type: \"custom\", resourceType: \"instance\", name: \"my-instance\" },\n *   \"labels\", \"app\", \"my-app\"\n * );\n *\n * // Patch builtin resource metadata\n * await patchResourceMetadata(context,\n *   { type: \"builtin\", resourceType: \"pod\", name: \"my-pod\" },\n *   \"annotations\", \"description\", \"My pod\"\n * );\n * ```\n */\nexport const patchResourceMetadata = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n\tmetadataType: \"annotations\" | \"labels\",\n\tkey: string,\n\tvalue: string,\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await patchCustomResourceMetadata(\n\t\t\tcontext,\n\t\t\ttarget as CustomResourceTarget,\n\t\t\tmetadataType,\n\t\t\tkey,\n\t\t\tvalue,\n\t\t);\n\t} else {\n\t\treturn await patchBuiltinResourceMetadata(\n\t\t\tcontext,\n\t\t\ttarget as BuiltinResourceTarget,\n\t\t\tmetadataType,\n\t\t\tkey,\n\t\t\tvalue,\n\t\t);\n\t}\n};\n\n/**\n * Remove resource metadata (annotations or labels) automatically determining if it's builtin or custom.\n *\n * @example\n * ```typescript\n * // Remove custom resource metadata\n * await removeResourceMetadata(context,\n *   { type: \"custom\", resourceType: \"instance\", name: \"my-instance\" },\n *   \"labels\", \"app\"\n * );\n *\n * // Remove builtin resource metadata\n * await removeResourceMetadata(context,\n *   { type: \"builtin\", resourceType: \"pod\", name: \"my-pod\" },\n *   \"annotations\", \"description\"\n * );\n * ```\n */\nexport const removeResourceMetadata = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n\tmetadataType: \"annotations\" | \"labels\",\n\tkey: string,\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await removeCustomResourceMetadata(\n\t\t\tcontext,\n\t\t\ttarget as CustomResourceTarget,\n\t\t\tmetadataType,\n\t\t\tkey,\n\t\t);\n\t} else {\n\t\treturn await removeBuiltinResourceMetadata(\n\t\t\tcontext,\n\t\t\ttarget as BuiltinResourceTarget,\n\t\t\tmetadataType,\n\t\t\tkey,\n\t\t);\n\t}\n};\n\n/**\n * Patch a resource with arbitrary patch operations automatically determining if it's builtin or custom.\n *\n * @example\n * ```typescript\n * // Patch custom resource\n * await patchResource(context,\n *   { type: \"custom\", resourceType: \"instance\", name: \"my-instance\" },\n *   [{ op: \"replace\", path: \"/spec/replicas\", value: 3 }]\n * );\n *\n * // Patch builtin resource\n * await patchResource(context,\n *   { type: \"builtin\", resourceType: \"deployment\", name: \"my-deployment\" },\n *   [{ op: \"replace\", path: \"/spec/replicas\", value: 5 }]\n * );\n * ```\n */\nexport const patchResource = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n\tpatchBody: Operation[],\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await patchCustomResource(\n\t\t\tcontext,\n\t\t\ttarget as CustomResourceTarget,\n\t\t\tpatchBody,\n\t\t);\n\t} else {\n\t\treturn await patchBuiltinResource(\n\t\t\tcontext,\n\t\t\ttarget as BuiltinResourceTarget,\n\t\t\tpatchBody,\n\t\t);\n\t}\n};\n\n/**\n * Strategic merge patch for a resource automatically determining if it's builtin or custom.\n * This allows partial updates without needing to get the full resource first.\n *\n * @example\n * ```typescript\n * // Strategic merge patch custom resource\n * await strategicMergePatchResource(context,\n *   { type: \"custom\", resourceType: \"instance\", name: \"my-instance\" },\n *   { spec: { replicas: 3 } }\n * );\n *\n * // Strategic merge patch builtin resource\n * await strategicMergePatchResource(context,\n *   { type: \"builtin\", resourceType: \"deployment\", name: \"my-deployment\" },\n *   { spec: { replicas: 5 } }\n * );\n * ```\n */\nexport const strategicMergePatchResource = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n\tpatchBody: Record<string, unknown>,\n) => {\n\tif (target.type === \"custom\") {\n\t\treturn await strategicMergePatchCustomResource(\n\t\t\tcontext,\n\t\t\ttarget as CustomResourceTarget,\n\t\t\tpatchBody,\n\t\t);\n\t} else {\n\t\treturn await strategicMergePatchBuiltinResource(\n\t\t\tcontext,\n\t\t\ttarget as BuiltinResourceTarget,\n\t\t\tpatchBody,\n\t\t);\n\t}\n};\n\n/**\n * Apply resource content (JSON or YAML) automatically determining if it's builtin or custom.\n * This is a wrapper around the mutation API's applyResource function.\n *\n * @example\n * ```typescript\n * // Apply YAML content with target\n * const result = await applyResource(context,\n *   { type: \"custom\", resourceType: \"instance\", name: \"my-instance\" },\n *   yamlContent\n * );\n * ```\n */\nexport const applyResource = async (\n\tcontext: K8sContext,\n\ttarget: ResourceTarget,\n\tresourceContent: string | Record<string, unknown>,\n) => {\n\treturn await applyResourceMutation(context, target, resourceContent);\n};\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/new-york/lib/k8s/k8s.parser.ts",
      "content": "import { BUILTIN_RESOURCES } from \"@/registry/dark/constants/k8s/k8s-builtin.constant\";\nimport { CUSTOM_RESOURCES } from \"@/registry/dark/constants/k8s/k8s-custom.constant\";\nimport type {\n\tBuiltinResourceTarget,\n\tBuiltinResourceTypeTarget,\n\tCustomResourceTarget,\n\tCustomResourceTypeTarget,\n} from \"@/registry/dark/models/k8s/k8s.model\";\nimport type { K8sResource } from \"@/registry/dark/models/k8s/k8s-resource.model\";\n\n/**\n * Convert a resource type string to a resource type target\n * @param resourceType - The resource type (e.g., \"deployment\", \"pod\", \"devbox\")\n * @param name - Optional resource name\n * @param label - Optional label for filtering\n * @returns Resource type target for listing resources\n */\nconst fromTypeToTarget = (\n\tresourceType: string,\n\tname?: string,\n\tlabel?: string,\n): BuiltinResourceTypeTarget | CustomResourceTypeTarget => {\n\tconst lowerResourceType = resourceType.toLowerCase();\n\n\t// Check builtin resources first\n\tconst builtinConfig = BUILTIN_RESOURCES[lowerResourceType];\n\tif (builtinConfig) {\n\t\treturn {\n\t\t\ttype: \"builtin\",\n\t\t\tresourceType: builtinConfig.resourceType,\n\t\t\tname: name,\n\t\t\tlabel,\n\t\t};\n\t}\n\n\t// Check custom resources\n\tconst customConfig = CUSTOM_RESOURCES[lowerResourceType];\n\tif (customConfig) {\n\t\treturn {\n\t\t\ttype: \"custom\",\n\t\t\tresourceType: customConfig.resourceType,\n\t\t\tname: name,\n\t\t\tlabel,\n\t\t};\n\t}\n\n\tthrow new Error(`Unknown resource type: ${resourceType}`);\n};\n\n/**\n * Convert a Kubernetes resource to a resource target\n * @param resource - The Kubernetes resource object\n * @returns Resource target for specific resource operations\n */\nconst fromResourceToTarget = (\n\tresource: K8sResource,\n): BuiltinResourceTarget | CustomResourceTarget => {\n\tif (!resource.metadata.name) {\n\t\tthrow new Error(\"Resource name is required\");\n\t}\n\n\tif (!resource.kind) {\n\t\tthrow new Error(\"Resource kind is required\");\n\t}\n\n\tconst lowerKind = resource.kind.toLowerCase();\n\n\t// Check builtin resources first\n\tconst builtinConfig = BUILTIN_RESOURCES[lowerKind];\n\tif (builtinConfig) {\n\t\treturn {\n\t\t\ttype: \"builtin\",\n\t\t\tresourceType: builtinConfig.resourceType,\n\t\t\tname: resource.metadata.name,\n\t\t};\n\t}\n\n\t// Check custom resources\n\tconst customConfig = CUSTOM_RESOURCES[lowerKind];\n\tif (customConfig) {\n\t\treturn {\n\t\t\ttype: \"custom\",\n\t\t\tresourceType: customConfig.resourceType,\n\t\t\tname: resource.metadata.name,\n\t\t};\n\t}\n\n\tthrow new Error(`Unknown resource kind: ${resource.kind}`);\n};\n\n/**\n * Convert an unknown object to a resource target if possible\n * @param object - The object expected to have name and resourceType\n * @returns Resource target for specific resource operations\n */\nconst fromObjectToTarget = (\n\tobject: unknown,\n): BuiltinResourceTarget | CustomResourceTarget => {\n\tif (typeof object !== \"object\" || object === null) {\n\t\tthrow new Error(\"Object must be a non-null object\");\n\t}\n\n\t// Use safe property extraction without `any`\n\tconst resourceType =\n\t\t\"resourceType\" in object &&\n\t\ttypeof (object as { resourceType: unknown }).resourceType === \"string\"\n\t\t\t? (object as { resourceType: string }).resourceType\n\t\t\t: undefined;\n\tconst name =\n\t\t\"name\" in object && typeof (object as { name: unknown }).name === \"string\"\n\t\t\t? (object as { name: string }).name\n\t\t\t: undefined;\n\n\tif (typeof resourceType !== \"string\") {\n\t\tthrow new Error(\"Object must have a string resourceType property\");\n\t}\n\tif (typeof name !== \"string\") {\n\t\tthrow new Error(\"Object must have a string name property\");\n\t}\n\n\tconst lowerResourceType = resourceType.toLowerCase();\n\n\t// Check builtin resources first\n\tconst builtinConfig = BUILTIN_RESOURCES[lowerResourceType];\n\tif (builtinConfig) {\n\t\treturn {\n\t\t\ttype: \"builtin\",\n\t\t\tresourceType: builtinConfig.resourceType,\n\t\t\tname: name,\n\t\t};\n\t}\n\n\t// Check custom resources\n\tconst customConfig = CUSTOM_RESOURCES[lowerResourceType];\n\tif (customConfig) {\n\t\treturn {\n\t\t\ttype: \"custom\",\n\t\t\tresourceType: customConfig.resourceType,\n\t\t\tname: name,\n\t\t};\n\t}\n\n\tthrow new Error(`Unknown resource type: ${resourceType}`);\n};\n\nexport const k8sParser = {\n\tfromTypeToTarget,\n\tfromResourceToTarget,\n\tfromObjectToTarget,\n};\n",
      "type": "registry:lib"
    }
  ]
}