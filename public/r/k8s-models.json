{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "k8s-models",
  "type": "registry:item",
  "title": "Kubernetes Models",
  "description": "Complete set of Zod schemas for Kubernetes resources, including builtin resources, custom resources, API clients, and context models.",
  "dependencies": [
    "zod"
  ],
  "files": [
    {
      "path": "src/registry/new-york/models/k8s/k8s-builtin.model.ts",
      "content": "import { z } from \"zod\";\n\nexport const BuiltinResourceConfigSchema = z.object({\n\ttype: z.literal(\"builtin\"),\n\tresourceType: z.enum([\n\t\t\"deployment\",\n\t\t\"service\",\n\t\t\"ingress\",\n\t\t\"statefulset\",\n\t\t\"daemonset\",\n\t\t\"configmap\",\n\t\t\"secret\",\n\t\t\"pod\",\n\t\t\"pvc\",\n\t\t\"hpa\",\n\t\t\"role\",\n\t\t\"rolebinding\",\n\t\t\"serviceaccount\",\n\t\t\"job\",\n\t\t\"cronjob\",\n\t\t\"resourcequota\",\n\t\t\"event\",\n\t]),\n\tapiVersion: z.string(),\n\tkind: z.string(),\n\tlistMethod: z.string(),\n\tgetMethod: z.string(),\n\tcreateMethod: z.string(),\n\tdeleteMethod: z.string(),\n\tpatchMethod: z.string(),\n\treplaceMethod: z.string(),\n\tdeleteCollectionMethod: z.string().optional(),\n\tapiClient: z.string(),\n});\n\nexport const BuiltinResourceTargetSchema = z.object({\n\ttype: z.literal(\"builtin\"),\n\tresourceType: z.enum([\n\t\t\"deployment\",\n\t\t\"service\",\n\t\t\"ingress\",\n\t\t\"statefulset\",\n\t\t\"daemonset\",\n\t\t\"configmap\",\n\t\t\"secret\",\n\t\t\"pod\",\n\t\t\"pvc\",\n\t\t\"hpa\",\n\t\t\"role\",\n\t\t\"rolebinding\",\n\t\t\"serviceaccount\",\n\t\t\"job\",\n\t\t\"cronjob\",\n\t\t\"resourcequota\",\n\t\t\"event\",\n\t]),\n\tname: z.string(),\n});\n\nexport const BuiltinResourceTypeTargetSchema = z\n\t.object({\n\t\ttype: z.literal(\"builtin\"),\n\t\tresourceType: z.string(),\n\t\tname: z.string().optional(),\n\t\tlabel: z.string().optional(),\n\t})\n\t.refine(\n\t\t(data) => {\n\t\t\t// If label is present, name must also be provided\n\t\t\tif (data.label && data.label !== \"\") {\n\t\t\t\treturn data.name !== undefined && data.name !== \"\";\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t{\n\t\t\tmessage: \"If label is provided, name must also be provided\",\n\t\t\tpath: [\"name\"],\n\t\t},\n\t);\n\n// Derived types from schemas\nexport type BuiltinResourceConfig = z.infer<typeof BuiltinResourceConfigSchema>;\nexport type BuiltinResourceTarget = z.infer<typeof BuiltinResourceTargetSchema>;\nexport type BuiltinResourceTypeTarget = z.infer<\n\ttypeof BuiltinResourceTypeTargetSchema\n>;\n",
      "type": "registry:item"
    },
    {
      "path": "src/registry/new-york/models/k8s/k8s-clients.model.ts",
      "content": "import { z } from \"zod\";\n\n// Schema definitions\nexport const K8sClientsSchema = z.object({\n\tcustomApi: z.any(), // CustomObjectsApi\n\tappsApi: z.any(), // AppsV1Api\n\tautoscalingApi: z.any(), // AutoscalingV2Api\n\tbatchApi: z.any(), // BatchV1Api\n\tcoreApi: z.any(), // CoreV1Api\n\tnetworkingApi: z.any(), // NetworkingV1Api\n\trbacApi: z.any(), // RbacAuthorizationV1Api\n});\n\n// Derived types from schemas\nexport type K8sApiClients = z.infer<typeof K8sClientsSchema>;\n",
      "type": "registry:item"
    },
    {
      "path": "src/registry/new-york/models/k8s/k8s-context.model.ts",
      "content": "import { z } from \"zod\";\n\n// Context schema definition\nexport const K8sContextSchema = z.object({\n\tkubeconfig: z.string(),\n});\n\n// Derived type from schema\nexport type K8sContext = z.infer<typeof K8sContextSchema>;\n",
      "type": "registry:item"
    },
    {
      "path": "src/registry/new-york/models/k8s/k8s-custom.model.ts",
      "content": "import { z } from \"zod\";\n\nexport const CustomResourceConfigSchema = z.object({\n\ttype: z.literal(\"custom\"),\n\tresourceType: z.enum([\n\t\t\"issuer\",\n\t\t\"certificate\",\n\t\t\"backup\",\n\t\t\"devbox\",\n\t\t\"cluster\",\n\t\t\"instance\",\n\t\t\"objectstoragebucket\",\n\t\t\"app\",\n\t]),\n\tgroup: z.string(),\n\tversion: z.string(),\n\tplural: z.string(),\n});\n\nexport const CustomResourceTargetSchema = z.object({\n\ttype: z.literal(\"custom\"),\n\tresourceType: z.enum([\n\t\t\"issuer\",\n\t\t\"certificate\",\n\t\t\"backup\",\n\t\t\"devbox\",\n\t\t\"cluster\",\n\t\t\"instance\",\n\t\t\"objectstoragebucket\",\n\t\t\"app\",\n\t]),\n\tname: z.string(),\n});\n\nexport const CustomResourceTypeTargetSchema = z\n\t.object({\n\t\ttype: z.literal(\"custom\"),\n\t\tresourceType: z.string(),\n\t\tname: z.string().optional(),\n\t\tlabel: z.string().optional(),\n\t})\n\t.refine(\n\t\t(data) => {\n\t\t\t// If label is present, name must also be provided\n\t\t\tif (data.label && data.label !== \"\") {\n\t\t\t\treturn data.name !== undefined && data.name !== \"\";\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t{\n\t\t\tmessage: \"If label is provided, name must also be provided\",\n\t\t\tpath: [\"name\"],\n\t\t},\n\t);\n\n// Derived types from schemas\nexport type CustomResourceConfig = z.infer<typeof CustomResourceConfigSchema>;\nexport type CustomResourceTarget = z.infer<typeof CustomResourceTargetSchema>;\nexport type CustomResourceTypeTarget = z.infer<\n\ttypeof CustomResourceTypeTargetSchema\n>;\n",
      "type": "registry:item"
    },
    {
      "path": "src/registry/new-york/models/k8s/k8s-object.model.ts",
      "content": "import { z } from \"zod\";\n\n// Base Kubernetes object schema with mandatory fields\nexport const K8sObjectSchema = z\n\t.object({\n\t\tname: z.string(),\n\t\tresourceType: z.string(),\n\t})\n\t.passthrough(); // Allow additional fields without validation\n\n// Type export\nexport type K8sObject = z.infer<typeof K8sObjectSchema>;\n",
      "type": "registry:item"
    },
    {
      "path": "src/registry/new-york/models/k8s/k8s-resource.model.ts",
      "content": "import { z } from \"zod\";\n\n// Environment variable schema\nexport const EnvSchema = z\n\t.object({\n\t\tname: z.string(),\n\t\tvalue: z.string().optional(),\n\t\tvalueFrom: z\n\t\t\t.object({\n\t\t\t\tsecretKeyRef: z.object({\n\t\t\t\t\tname: z.string(),\n\t\t\t\t\tkey: z.string(),\n\t\t\t\t}),\n\t\t\t})\n\t\t\t.optional(),\n\t})\n\t.refine((data) => data.value || data.valueFrom, {\n\t\tmessage: \"Either 'value' or 'valueFrom' must be provided\",\n\t});\n\n// Base Kubernetes resource schema\nexport const K8sResourceSchema = z.object({\n\tapiVersion: z.string(),\n\tkind: z.string(),\n\tmetadata: z.object({\n\t\tname: z.string(),\n\t\tnamespace: z.string().optional(),\n\t\tuid: z.string().optional(),\n\t\tresourceVersion: z.string().optional(),\n\t\tgeneration: z.number().optional(),\n\t\tcreationTimestamp: z.string().optional(),\n\t\tdeletionTimestamp: z.string().optional(),\n\t\tlabels: z.record(z.string()).optional(),\n\t\tannotations: z.record(z.string()).optional(),\n\t\townerReferences: z\n\t\t\t.array(\n\t\t\t\tz.object({\n\t\t\t\t\tapiVersion: z.string(),\n\t\t\t\t\tkind: z.string(),\n\t\t\t\t\tname: z.string(),\n\t\t\t\t\tuid: z.string(),\n\t\t\t\t\tcontroller: z.boolean().optional(),\n\t\t\t\t\tblockOwnerDeletion: z.boolean().optional(),\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.optional(),\n\t\tfinalizers: z.array(z.string()).optional(),\n\t}),\n\tspec: z.record(z.unknown()).optional(),\n\tstatus: z.record(z.unknown()).optional(),\n\tdata: z.record(z.unknown()).optional(),\n});\n\n// Event-specific schema\nexport const K8sEventSchema = z.object({\n\tapiVersion: z.string(),\n\tkind: z.string(),\n\tmetadata: z.object({\n\t\tname: z.string(),\n\t\tnamespace: z.string().optional(),\n\t\tuid: z.string().optional(),\n\t\tresourceVersion: z.string().optional(),\n\t\tgeneration: z.number().optional(),\n\t\tcreationTimestamp: z.string().optional(),\n\t\tdeletionTimestamp: z.string().optional(),\n\t\tlabels: z.record(z.string()).optional(),\n\t\tannotations: z.record(z.string()).optional(),\n\t\townerReferences: z\n\t\t\t.array(\n\t\t\t\tz.object({\n\t\t\t\t\tapiVersion: z.string(),\n\t\t\t\t\tkind: z.string(),\n\t\t\t\t\tname: z.string(),\n\t\t\t\t\tuid: z.string(),\n\t\t\t\t\tcontroller: z.boolean().optional(),\n\t\t\t\t\tblockOwnerDeletion: z.boolean().optional(),\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.optional(),\n\t\tfinalizers: z.array(z.string()).optional(),\n\t}),\n\tcount: z.number().optional(),\n\teventTime: z.string().nullable().optional(),\n\tfirstTimestamp: z.string().optional(),\n\tinvolvedObject: z.object({\n\t\tapiVersion: z.string(),\n\t\tfieldPath: z.string().optional(),\n\t\tkind: z.string(),\n\t\tname: z.string(),\n\t\tnamespace: z.string().optional(),\n\t\tresourceVersion: z.string().optional(),\n\t\tuid: z.string().optional(),\n\t}),\n\tlastTimestamp: z.string().optional(),\n\tmessage: z.string().optional(),\n\treason: z.string().optional(),\n\treportingComponent: z.string().optional(),\n\treportingInstance: z.string().optional(),\n\tsource: z\n\t\t.object({\n\t\t\tcomponent: z.string(),\n\t\t\thost: z.string(),\n\t\t})\n\t\t.optional(),\n\ttype: z.string().optional(),\n});\n\n// Name schema for Kubernetes resources (DNS compliant)\nexport const NameSchema = z\n\t.string()\n\t.min(1, \"Name is required\")\n\t.max(63, \"Name must be 63 characters or less\")\n\t.regex(\n\t\t/^[a-z0-9]([-a-z0-9]*[a-z0-9])?$/,\n\t\t\"Name must be DNS compliant: lowercase, numbers, hyphens only\",\n\t);\n\n// Kubernetes resource list schema\nexport const K8sResourceListSchema = z.object({\n\tapiVersion: z.string(),\n\tkind: z.string(),\n\tmetadata: z\n\t\t.object({\n\t\t\tresourceVersion: z.string().optional(),\n\t\t\tselfLink: z.string().optional(),\n\t\t})\n\t\t.optional(),\n\titems: z.array(K8sResourceSchema),\n});\n\n// K8s Item schema - mandates name and resourceType, allows other fields\nexport const K8sItemSchema = z\n\t.object({\n\t\tname: z.string(),\n\t\tuid: z.string(),\n\t\tresourceType: z.string(),\n\t})\n\t.passthrough();\n\n// Type exports\nexport type Env = z.infer<typeof EnvSchema>;\nexport type K8sResource = z.infer<typeof K8sResourceSchema>;\nexport type K8sEvent = z.infer<typeof K8sEventSchema>;\nexport type K8sResourceList = z.infer<typeof K8sResourceListSchema>;\nexport type K8sItem = z.infer<typeof K8sItemSchema>;\nexport type Name = z.infer<typeof NameSchema>;\n",
      "type": "registry:item"
    },
    {
      "path": "src/registry/new-york/models/k8s/k8s.model.ts",
      "content": "// Re-export all models from the split files\nexport * from \"./k8s-builtin.model\";\nexport * from \"./k8s-clients.model\";\nexport * from \"./k8s-custom.model\";\n\n// Union schemas for convenience\nimport { z } from \"zod\";\nimport { BuiltinResourceTargetSchema, BuiltinResourceTypeTargetSchema } from \"./k8s-builtin.model\";\nimport { CustomResourceTargetSchema, CustomResourceTypeTargetSchema } from \"./k8s-custom.model\";\n\nexport const resourceTargetSchema = z.union([\n\tBuiltinResourceTargetSchema,\n\tCustomResourceTargetSchema,\n]);\n\nexport const resourceTypeTargetSchema = z.union([\n\tBuiltinResourceTypeTargetSchema,\n\tCustomResourceTypeTargetSchema,\n]);\n\n// Derived types from union schemas\nexport type ResourceTarget = z.infer<typeof resourceTargetSchema>;\nexport type ResourceTypeTarget = z.infer<typeof resourceTypeTargetSchema>;\n",
      "type": "registry:item"
    }
  ]
}